// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: walletunlocker.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
	struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
	typealias Version = _2
}

struct Lnrpc_GenSeedRequest {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	///
	/// aezeed_passphrase is an optional user provided passphrase that will be used
	/// to encrypt the generated aezeed cipher seed. When using REST, this field
	/// must be encoded as base64.
	var aezeedPassphrase: Data = .init()

	///
	/// seed_entropy is an optional 16-bytes generated via CSPRNG. If not
	/// specified, then a fresh set of randomness will be used to create the seed.
	/// When using REST, this field must be encoded as base64.
	var seedEntropy: Data = .init()

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() {}
}

struct Lnrpc_GenSeedResponse {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	///
	/// cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
	/// cipher seed obtained by the user. This field is optional, as if not
	/// provided, then the daemon will generate a new cipher seed for the user.
	/// Otherwise, then the daemon will attempt to recover the wallet state linked
	/// to this cipher seed.
	var cipherSeedMnemonic: [String] = []

	///
	/// enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
	/// cipher text before run through our mnemonic encoding scheme.
	var encipheredSeed: Data = .init()

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() {}
}

struct Lnrpc_InitWalletRequest {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	///
	/// wallet_password is the passphrase that should be used to encrypt the
	/// wallet. This MUST be at least 8 chars in length. After creation, this
	/// password is required to unlock the daemon. When using REST, this field
	/// must be encoded as base64.
	var walletPassword: Data = .init()

	///
	/// cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
	/// cipher seed obtained by the user. This may have been generated by the
	/// GenSeed method, or be an existing seed.
	var cipherSeedMnemonic: [String] = []

	///
	/// aezeed_passphrase is an optional user provided passphrase that will be used
	/// to encrypt the generated aezeed cipher seed. When using REST, this field
	/// must be encoded as base64.
	var aezeedPassphrase: Data = .init()

	///
	/// recovery_window is an optional argument specifying the address lookahead
	/// when restoring a wallet seed. The recovery window applies to each
	/// individual branch of the BIP44 derivation paths. Supplying a recovery
	/// window of zero indicates that no addresses should be recovered, such after
	/// the first initialization of the wallet.
	var recoveryWindow: Int32 = 0

	///
	/// channel_backups is an optional argument that allows clients to recover the
	/// settled funds within a set of channels. This should be populated if the
	/// user was unable to close out all channels and sweep funds before partial or
	/// total data loss occurred. If specified, then after on-chain recovery of
	/// funds, lnd begin to carry out the data loss recovery protocol in order to
	/// recover the funds in each channel from a remote force closed transaction.
	var channelBackups: Lnrpc_ChanBackupSnapshot {
		get { return _channelBackups ?? Lnrpc_ChanBackupSnapshot() }
		set { _channelBackups = newValue }
	}

	/// Returns true if `channelBackups` has been explicitly set.
	var hasChannelBackups: Bool { return self._channelBackups != nil }
	/// Clears the value of `channelBackups`. Subsequent reads from it will return its default value.
	mutating func clearChannelBackups() { _channelBackups = nil }

	///
	/// stateless_init is an optional argument instructing the daemon NOT to create
	/// any *.macaroon files in its filesystem. If this parameter is set, then the
	/// admin macaroon returned in the response MUST be stored by the caller of the
	/// RPC as otherwise all access to the daemon will be lost!
	var statelessInit: Bool = false

	///
	/// extended_master_key is an alternative to specifying cipher_seed_mnemonic and
	/// aezeed_passphrase. Instead of deriving the master root key from the entropy
	/// of an aezeed cipher seed, the given extended master root key is used
	/// directly as the wallet's master key. This allows users to import/use a
	/// master key from another wallet. When doing so, lnd still uses its default
	/// SegWit only (BIP49/84) derivation paths and funds from custom/non-default
	/// derivation paths will not automatically appear in the on-chain wallet. Using
	/// an 'xprv' instead of an aezeed also has the disadvantage that the wallet's
	/// birthday is not known as that is an information that's only encoded in the
	/// aezeed, not the xprv. Therefore a birthday needs to be specified in
	/// extended_master_key_birthday_timestamp or a "safe" default value will be
	/// used.
	var extendedMasterKey: String = .init()

	///
	/// extended_master_key_birthday_timestamp is the optional unix timestamp in
	/// seconds to use as the wallet's birthday when using an extended master key
	/// to restore the wallet. lnd will only start scanning for funds in blocks that
	/// are after the birthday which can speed up the process significantly. If the
	/// birthday is not known, this should be left at its default value of 0 in
	/// which case lnd will start scanning from the first SegWit block (481824 on
	/// mainnet).
	var extendedMasterKeyBirthdayTimestamp: UInt64 = 0

	///
	/// watch_only is the third option of initializing a wallet: by importing
	/// account xpubs only and therefore creating a watch-only wallet that does not
	/// contain any private keys. That means the wallet won't be able to sign for
	/// any of the keys and _needs_ to be run with a remote signer that has the
	/// corresponding private keys and can serve signing RPC requests.
	var watchOnly: Lnrpc_WatchOnly {
		get { return _watchOnly ?? Lnrpc_WatchOnly() }
		set { _watchOnly = newValue }
	}

	/// Returns true if `watchOnly` has been explicitly set.
	var hasWatchOnly: Bool { return self._watchOnly != nil }
	/// Clears the value of `watchOnly`. Subsequent reads from it will return its default value.
	mutating func clearWatchOnly() { _watchOnly = nil }

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() {}

	fileprivate var _channelBackups: Lnrpc_ChanBackupSnapshot?
	fileprivate var _watchOnly: Lnrpc_WatchOnly?
}

struct Lnrpc_InitWalletResponse {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	///
	/// The binary serialized admin macaroon that can be used to access the daemon
	/// after creating the wallet. If the stateless_init parameter was set to true,
	/// this is the ONLY copy of the macaroon and MUST be stored safely by the
	/// caller. Otherwise a copy of this macaroon is also persisted on disk by the
	/// daemon, together with other macaroon files.
	var adminMacaroon: Data = .init()

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() {}
}

struct Lnrpc_WatchOnly {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	///
	/// The unix timestamp in seconds of when the master key was created. lnd will
	/// only start scanning for funds in blocks that are after the birthday which
	/// can speed up the process significantly. If the birthday is not known, this
	/// should be left at its default value of 0 in which case lnd will start
	/// scanning from the first SegWit block (481824 on mainnet).
	var masterKeyBirthdayTimestamp: UInt64 = 0

	///
	/// The fingerprint of the root key (also known as the key with derivation path
	/// m/) from which the account public keys were derived from. This may be
	/// required by some hardware wallets for proper identification and signing. The
	/// bytes must be in big-endian order.
	var masterKeyFingerprint: Data = .init()

	///
	/// The list of accounts to import. There _must_ be an account for all of lnd's
	/// main key scopes: BIP49/BIP84 (m/49'/0'/0', m/84'/0'/0', note that the
	/// coin type is always 0, even for testnet/regtest) and lnd's internal key
	/// scope (m/1017'/<coin_type>'/<account>'), where account is the key family as
	/// defined in `keychain/derivation.go` (currently indices 0 to 9).
	var accounts: [Lnrpc_WatchOnlyAccount] = []

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() {}
}

struct Lnrpc_WatchOnlyAccount {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	///
	/// Purpose is the first number in the derivation path, must be either 49, 84
	/// or 1017.
	var purpose: UInt32 = 0

	///
	/// Coin type is the second number in the derivation path, this is _always_ 0
	/// for purposes 49 and 84. It only needs to be set to 1 for purpose 1017 on
	/// testnet or regtest.
	var coinType: UInt32 = 0

	///
	/// Account is the third number in the derivation path. For purposes 49 and 84
	/// at least the default account (index 0) needs to be created but optional
	/// additional accounts are allowed. For purpose 1017 there needs to be exactly
	/// one account for each of the key families defined in `keychain/derivation.go`
	/// (currently indices 0 to 9)
	var account: UInt32 = 0

	///
	/// The extended public key at depth 3 for the given account.
	var xpub: String = .init()

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() {}
}

struct Lnrpc_UnlockWalletRequest {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	///
	/// wallet_password should be the current valid passphrase for the daemon. This
	/// will be required to decrypt on-disk material that the daemon requires to
	/// function properly. When using REST, this field must be encoded as base64.
	var walletPassword: Data = .init()

	///
	/// recovery_window is an optional argument specifying the address lookahead
	/// when restoring a wallet seed. The recovery window applies to each
	/// individual branch of the BIP44 derivation paths. Supplying a recovery
	/// window of zero indicates that no addresses should be recovered, such after
	/// the first initialization of the wallet.
	var recoveryWindow: Int32 = 0

	///
	/// channel_backups is an optional argument that allows clients to recover the
	/// settled funds within a set of channels. This should be populated if the
	/// user was unable to close out all channels and sweep funds before partial or
	/// total data loss occurred. If specified, then after on-chain recovery of
	/// funds, lnd begin to carry out the data loss recovery protocol in order to
	/// recover the funds in each channel from a remote force closed transaction.
	var channelBackups: Lnrpc_ChanBackupSnapshot {
		get { return _channelBackups ?? Lnrpc_ChanBackupSnapshot() }
		set { _channelBackups = newValue }
	}

	/// Returns true if `channelBackups` has been explicitly set.
	var hasChannelBackups: Bool { return self._channelBackups != nil }
	/// Clears the value of `channelBackups`. Subsequent reads from it will return its default value.
	mutating func clearChannelBackups() { _channelBackups = nil }

	///
	/// stateless_init is an optional argument instructing the daemon NOT to create
	/// any *.macaroon files in its file system.
	var statelessInit: Bool = false

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() {}

	fileprivate var _channelBackups: Lnrpc_ChanBackupSnapshot?
}

struct Lnrpc_UnlockWalletResponse {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() {}
}

struct Lnrpc_ChangePasswordRequest {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	///
	/// current_password should be the current valid passphrase used to unlock the
	/// daemon. When using REST, this field must be encoded as base64.
	var currentPassword: Data = .init()

	///
	/// new_password should be the new passphrase that will be needed to unlock the
	/// daemon. When using REST, this field must be encoded as base64.
	var newPassword: Data = .init()

	///
	/// stateless_init is an optional argument instructing the daemon NOT to create
	/// any *.macaroon files in its filesystem. If this parameter is set, then the
	/// admin macaroon returned in the response MUST be stored by the caller of the
	/// RPC as otherwise all access to the daemon will be lost!
	var statelessInit: Bool = false

	///
	/// new_macaroon_root_key is an optional argument instructing the daemon to
	/// rotate the macaroon root key when set to true. This will invalidate all
	/// previously generated macaroons.
	var newMacaroonRootKey: Bool = false

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() {}
}

struct Lnrpc_ChangePasswordResponse {
	// SwiftProtobuf.Message conformance is added in an extension below. See the
	// `Message` and `Message+*Additions` files in the SwiftProtobuf library for
	// methods supported on all messages.

	///
	/// The binary serialized admin macaroon that can be used to access the daemon
	/// after rotating the macaroon root key. If both the stateless_init and
	/// new_macaroon_root_key parameter were set to true, this is the ONLY copy of
	/// the macaroon that was created from the new root key and MUST be stored
	/// safely by the caller. Otherwise a copy of this macaroon is also persisted on
	/// disk by the daemon, together with other macaroon files.
	var adminMacaroon: Data = .init()

	var unknownFields = SwiftProtobuf.UnknownStorage()

	init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
	extension Lnrpc_GenSeedRequest: @unchecked Sendable {}
	extension Lnrpc_GenSeedResponse: @unchecked Sendable {}
	extension Lnrpc_InitWalletRequest: @unchecked Sendable {}
	extension Lnrpc_InitWalletResponse: @unchecked Sendable {}
	extension Lnrpc_WatchOnly: @unchecked Sendable {}
	extension Lnrpc_WatchOnlyAccount: @unchecked Sendable {}
	extension Lnrpc_UnlockWalletRequest: @unchecked Sendable {}
	extension Lnrpc_UnlockWalletResponse: @unchecked Sendable {}
	extension Lnrpc_ChangePasswordRequest: @unchecked Sendable {}
	extension Lnrpc_ChangePasswordResponse: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "lnrpc"

extension Lnrpc_GenSeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".GenSeedRequest"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "aezeed_passphrase"),
		2: .standard(proto: "seed_entropy"),
	]

	mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
			case 1: try decoder.decodeSingularBytesField(value: &aezeedPassphrase)
			case 2: try decoder.decodeSingularBytesField(value: &seedEntropy)
			default: break
			}
		}
	}

	func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
		if !aezeedPassphrase.isEmpty {
			try visitor.visitSingularBytesField(value: aezeedPassphrase, fieldNumber: 1)
		}
		if !seedEntropy.isEmpty {
			try visitor.visitSingularBytesField(value: seedEntropy, fieldNumber: 2)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Lnrpc_GenSeedRequest, rhs: Lnrpc_GenSeedRequest) -> Bool {
		if lhs.aezeedPassphrase != rhs.aezeedPassphrase { return false }
		if lhs.seedEntropy != rhs.seedEntropy { return false }
		if lhs.unknownFields != rhs.unknownFields { return false }
		return true
	}
}

extension Lnrpc_GenSeedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".GenSeedResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "cipher_seed_mnemonic"),
		2: .standard(proto: "enciphered_seed"),
	]

	mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
			case 1: try decoder.decodeRepeatedStringField(value: &cipherSeedMnemonic)
			case 2: try decoder.decodeSingularBytesField(value: &encipheredSeed)
			default: break
			}
		}
	}

	func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
		if !cipherSeedMnemonic.isEmpty {
			try visitor.visitRepeatedStringField(value: cipherSeedMnemonic, fieldNumber: 1)
		}
		if !encipheredSeed.isEmpty {
			try visitor.visitSingularBytesField(value: encipheredSeed, fieldNumber: 2)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Lnrpc_GenSeedResponse, rhs: Lnrpc_GenSeedResponse) -> Bool {
		if lhs.cipherSeedMnemonic != rhs.cipherSeedMnemonic { return false }
		if lhs.encipheredSeed != rhs.encipheredSeed { return false }
		if lhs.unknownFields != rhs.unknownFields { return false }
		return true
	}
}

extension Lnrpc_InitWalletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".InitWalletRequest"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "wallet_password"),
		2: .standard(proto: "cipher_seed_mnemonic"),
		3: .standard(proto: "aezeed_passphrase"),
		4: .standard(proto: "recovery_window"),
		5: .standard(proto: "channel_backups"),
		6: .standard(proto: "stateless_init"),
		7: .standard(proto: "extended_master_key"),
		8: .standard(proto: "extended_master_key_birthday_timestamp"),
		9: .standard(proto: "watch_only"),
	]

	mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
			case 1: try decoder.decodeSingularBytesField(value: &walletPassword)
			case 2: try decoder.decodeRepeatedStringField(value: &cipherSeedMnemonic)
			case 3: try decoder.decodeSingularBytesField(value: &aezeedPassphrase)
			case 4: try decoder.decodeSingularInt32Field(value: &recoveryWindow)
			case 5: try decoder.decodeSingularMessageField(value: &_channelBackups)
			case 6: try decoder.decodeSingularBoolField(value: &statelessInit)
			case 7: try decoder.decodeSingularStringField(value: &extendedMasterKey)
			case 8: try decoder.decodeSingularUInt64Field(value: &extendedMasterKeyBirthdayTimestamp)
			case 9: try decoder.decodeSingularMessageField(value: &_watchOnly)
			default: break
			}
		}
	}

	func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if !walletPassword.isEmpty {
			try visitor.visitSingularBytesField(value: walletPassword, fieldNumber: 1)
		}
		if !cipherSeedMnemonic.isEmpty {
			try visitor.visitRepeatedStringField(value: cipherSeedMnemonic, fieldNumber: 2)
		}
		if !aezeedPassphrase.isEmpty {
			try visitor.visitSingularBytesField(value: aezeedPassphrase, fieldNumber: 3)
		}
		if recoveryWindow != 0 {
			try visitor.visitSingularInt32Field(value: recoveryWindow, fieldNumber: 4)
		}
		try { if let v = self._channelBackups {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
		} }()
		if statelessInit != false {
			try visitor.visitSingularBoolField(value: statelessInit, fieldNumber: 6)
		}
		if !extendedMasterKey.isEmpty {
			try visitor.visitSingularStringField(value: extendedMasterKey, fieldNumber: 7)
		}
		if extendedMasterKeyBirthdayTimestamp != 0 {
			try visitor.visitSingularUInt64Field(value: extendedMasterKeyBirthdayTimestamp, fieldNumber: 8)
		}
		try { if let v = self._watchOnly {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
		} }()
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Lnrpc_InitWalletRequest, rhs: Lnrpc_InitWalletRequest) -> Bool {
		if lhs.walletPassword != rhs.walletPassword { return false }
		if lhs.cipherSeedMnemonic != rhs.cipherSeedMnemonic { return false }
		if lhs.aezeedPassphrase != rhs.aezeedPassphrase { return false }
		if lhs.recoveryWindow != rhs.recoveryWindow { return false }
		if lhs._channelBackups != rhs._channelBackups { return false }
		if lhs.statelessInit != rhs.statelessInit { return false }
		if lhs.extendedMasterKey != rhs.extendedMasterKey { return false }
		if lhs.extendedMasterKeyBirthdayTimestamp != rhs.extendedMasterKeyBirthdayTimestamp { return false }
		if lhs._watchOnly != rhs._watchOnly { return false }
		if lhs.unknownFields != rhs.unknownFields { return false }
		return true
	}
}

extension Lnrpc_InitWalletResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".InitWalletResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "admin_macaroon"),
	]

	mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
			case 1: try decoder.decodeSingularBytesField(value: &adminMacaroon)
			default: break
			}
		}
	}

	func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
		if !adminMacaroon.isEmpty {
			try visitor.visitSingularBytesField(value: adminMacaroon, fieldNumber: 1)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Lnrpc_InitWalletResponse, rhs: Lnrpc_InitWalletResponse) -> Bool {
		if lhs.adminMacaroon != rhs.adminMacaroon { return false }
		if lhs.unknownFields != rhs.unknownFields { return false }
		return true
	}
}

extension Lnrpc_WatchOnly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".WatchOnly"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "master_key_birthday_timestamp"),
		2: .standard(proto: "master_key_fingerprint"),
		3: .same(proto: "accounts"),
	]

	mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
			case 1: try decoder.decodeSingularUInt64Field(value: &masterKeyBirthdayTimestamp)
			case 2: try decoder.decodeSingularBytesField(value: &masterKeyFingerprint)
			case 3: try decoder.decodeRepeatedMessageField(value: &accounts)
			default: break
			}
		}
	}

	func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
		if masterKeyBirthdayTimestamp != 0 {
			try visitor.visitSingularUInt64Field(value: masterKeyBirthdayTimestamp, fieldNumber: 1)
		}
		if !masterKeyFingerprint.isEmpty {
			try visitor.visitSingularBytesField(value: masterKeyFingerprint, fieldNumber: 2)
		}
		if !accounts.isEmpty {
			try visitor.visitRepeatedMessageField(value: accounts, fieldNumber: 3)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Lnrpc_WatchOnly, rhs: Lnrpc_WatchOnly) -> Bool {
		if lhs.masterKeyBirthdayTimestamp != rhs.masterKeyBirthdayTimestamp { return false }
		if lhs.masterKeyFingerprint != rhs.masterKeyFingerprint { return false }
		if lhs.accounts != rhs.accounts { return false }
		if lhs.unknownFields != rhs.unknownFields { return false }
		return true
	}
}

extension Lnrpc_WatchOnlyAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".WatchOnlyAccount"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .same(proto: "purpose"),
		2: .standard(proto: "coin_type"),
		3: .same(proto: "account"),
		4: .same(proto: "xpub"),
	]

	mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
			case 1: try decoder.decodeSingularUInt32Field(value: &purpose)
			case 2: try decoder.decodeSingularUInt32Field(value: &coinType)
			case 3: try decoder.decodeSingularUInt32Field(value: &account)
			case 4: try decoder.decodeSingularStringField(value: &xpub)
			default: break
			}
		}
	}

	func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
		if purpose != 0 {
			try visitor.visitSingularUInt32Field(value: purpose, fieldNumber: 1)
		}
		if coinType != 0 {
			try visitor.visitSingularUInt32Field(value: coinType, fieldNumber: 2)
		}
		if account != 0 {
			try visitor.visitSingularUInt32Field(value: account, fieldNumber: 3)
		}
		if !xpub.isEmpty {
			try visitor.visitSingularStringField(value: xpub, fieldNumber: 4)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Lnrpc_WatchOnlyAccount, rhs: Lnrpc_WatchOnlyAccount) -> Bool {
		if lhs.purpose != rhs.purpose { return false }
		if lhs.coinType != rhs.coinType { return false }
		if lhs.account != rhs.account { return false }
		if lhs.xpub != rhs.xpub { return false }
		if lhs.unknownFields != rhs.unknownFields { return false }
		return true
	}
}

extension Lnrpc_UnlockWalletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".UnlockWalletRequest"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "wallet_password"),
		2: .standard(proto: "recovery_window"),
		3: .standard(proto: "channel_backups"),
		4: .standard(proto: "stateless_init"),
	]

	mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
			case 1: try decoder.decodeSingularBytesField(value: &walletPassword)
			case 2: try decoder.decodeSingularInt32Field(value: &recoveryWindow)
			case 3: try decoder.decodeSingularMessageField(value: &_channelBackups)
			case 4: try decoder.decodeSingularBoolField(value: &statelessInit)
			default: break
			}
		}
	}

	func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
		// The use of inline closures is to circumvent an issue where the compiler
		// allocates stack space for every if/case branch local when no optimizations
		// are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
		// https://github.com/apple/swift-protobuf/issues/1182
		if !walletPassword.isEmpty {
			try visitor.visitSingularBytesField(value: walletPassword, fieldNumber: 1)
		}
		if recoveryWindow != 0 {
			try visitor.visitSingularInt32Field(value: recoveryWindow, fieldNumber: 2)
		}
		try { if let v = self._channelBackups {
			try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
		} }()
		if statelessInit != false {
			try visitor.visitSingularBoolField(value: statelessInit, fieldNumber: 4)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Lnrpc_UnlockWalletRequest, rhs: Lnrpc_UnlockWalletRequest) -> Bool {
		if lhs.walletPassword != rhs.walletPassword { return false }
		if lhs.recoveryWindow != rhs.recoveryWindow { return false }
		if lhs._channelBackups != rhs._channelBackups { return false }
		if lhs.statelessInit != rhs.statelessInit { return false }
		if lhs.unknownFields != rhs.unknownFields { return false }
		return true
	}
}

extension Lnrpc_UnlockWalletResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".UnlockWalletResponse"
	static let _protobuf_nameMap = SwiftProtobuf._NameMap()

	mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
		while let _ = try decoder.nextFieldNumber() {}
	}

	func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Lnrpc_UnlockWalletResponse, rhs: Lnrpc_UnlockWalletResponse) -> Bool {
		if lhs.unknownFields != rhs.unknownFields { return false }
		return true
	}
}

extension Lnrpc_ChangePasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".ChangePasswordRequest"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "current_password"),
		2: .standard(proto: "new_password"),
		3: .standard(proto: "stateless_init"),
		4: .standard(proto: "new_macaroon_root_key"),
	]

	mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
			case 1: try decoder.decodeSingularBytesField(value: &currentPassword)
			case 2: try decoder.decodeSingularBytesField(value: &newPassword)
			case 3: try decoder.decodeSingularBoolField(value: &statelessInit)
			case 4: try decoder.decodeSingularBoolField(value: &newMacaroonRootKey)
			default: break
			}
		}
	}

	func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
		if !currentPassword.isEmpty {
			try visitor.visitSingularBytesField(value: currentPassword, fieldNumber: 1)
		}
		if !newPassword.isEmpty {
			try visitor.visitSingularBytesField(value: newPassword, fieldNumber: 2)
		}
		if statelessInit != false {
			try visitor.visitSingularBoolField(value: statelessInit, fieldNumber: 3)
		}
		if newMacaroonRootKey != false {
			try visitor.visitSingularBoolField(value: newMacaroonRootKey, fieldNumber: 4)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Lnrpc_ChangePasswordRequest, rhs: Lnrpc_ChangePasswordRequest) -> Bool {
		if lhs.currentPassword != rhs.currentPassword { return false }
		if lhs.newPassword != rhs.newPassword { return false }
		if lhs.statelessInit != rhs.statelessInit { return false }
		if lhs.newMacaroonRootKey != rhs.newMacaroonRootKey { return false }
		if lhs.unknownFields != rhs.unknownFields { return false }
		return true
	}
}

extension Lnrpc_ChangePasswordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
	static let protoMessageName: String = _protobuf_package + ".ChangePasswordResponse"
	static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
		1: .standard(proto: "admin_macaroon"),
	]

	mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
		while let fieldNumber = try decoder.nextFieldNumber() {
			// The use of inline closures is to circumvent an issue where the compiler
			// allocates stack space for every case branch when no optimizations are
			// enabled. https://github.com/apple/swift-protobuf/issues/1034
			switch fieldNumber {
			case 1: try decoder.decodeSingularBytesField(value: &adminMacaroon)
			default: break
			}
		}
	}

	func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
		if !adminMacaroon.isEmpty {
			try visitor.visitSingularBytesField(value: adminMacaroon, fieldNumber: 1)
		}
		try unknownFields.traverse(visitor: &visitor)
	}

	static func == (lhs: Lnrpc_ChangePasswordResponse, rhs: Lnrpc_ChangePasswordResponse) -> Bool {
		if lhs.adminMacaroon != rhs.adminMacaroon { return false }
		if lhs.unknownFields != rhs.unknownFields { return false }
		return true
	}
}
